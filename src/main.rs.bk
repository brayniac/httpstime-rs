#[macro_use]
extern crate log;
extern crate hyper;
extern crate time;
extern crate shuteye;
extern crate getopts;

use getopts::Options;
use hyper::client::Client;
use hyper::header::{Date, HttpDate};
use log::{Log, LogLevel, LogLevelFilter, LogMetadata, LogRecord};
use std::env;

const VERSION: &'static str = env!("CARGO_PKG_VERSION");

fn print_usage(program: &str, opts: Options) {
    let brief = format!("Usage: {} [options]", program);
    print!("{}", opts.usage(&brief));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optopt("s", "server", "server", "HOST|HOST:PORT");
    opts.optflag("d", "debug", "debug logging");
    opts.optflag("h", "help", "print this help menu");

    let matches = match opts.parse(&args[1..]) {
        Ok(m) => {
            m
        }
        Err(f) => {
            panic!(f.to_string())
        }
    };
    if matches.opt_present("h") {
        print_usage(&program, opts);
        return;
    }
    if !matches.opt_present("s") {
        error!("require server parameter");
        print_usage(&program, opts);
        return;
    }
    let server = matches.opt_str("s").unwrap();

    let mut log_filter = LogLevelFilter::Info;

    if matches.opt_present("d") {
        log_filter = LogLevelFilter::Debug;
    }

    let _ = log::set_logger(|max_log_level| {
        max_log_level.set(log_filter);
        return Box::new(SimpleLogger);
    });

    debug!("httpstime-rs {} initializing...", VERSION);

    let client = Client::new();

    let mut x0 = time::Duration::min_value();
    let mut x1 = time::Duration::max_value();

    for _ in 0..8 {
        let result = time_from_https(&client, server.clone());
        let t0 = result.t0 - time::Duration::seconds(1) - result.t2;
        let t1 = result.t1 - result.t2;
        let rtt = result.t1 - result.t0;

        if t0 > x0 {
            x0 = t0;

            if t1 < x1 {
                x1 = t1;
            }
            debug!("B");
        } else if t1 < x1 {
            x1 = t1;
            debug!("A");
        } else {
            debug!("C");
        }

        let mut dt = ((x1 + x0) / 2) - rtt / 2;

        while dt < time::Duration::zero() {
            dt = dt + time::Duration::seconds(1);
        }
        debug!("dt: {:?}", dt);

        let now = time::now_utc();

        // let mut b = dt;
        let mut b = dt - time::Duration::nanoseconds(now.to_timespec().nsec as i64);

        while b < time::Duration::zero() {
            b = b + time::Duration::seconds(1);
        }
        while b > time::Duration::seconds(1) {
            b = b - time::Duration::seconds(1);
        }
        debug!("b: {:?}", b);

        shuteye::sleep(shuteye::Timespec::from_nano(b.num_nanoseconds().unwrap()).unwrap());


    }
    let low = (x0.num_milliseconds() as f64) / 1000_f64;
    let high = (x1.num_milliseconds() as f64) / 1000_f64;
    let width = high - low;

    println!("*RESULT 0 {} {:.*} {:.*} {:.*}",
             server,
             3,
             low,
             3,
             high,
             3,
             width);

}

struct HttpsTimes {
    t0: time::Timespec,
    t1: time::Timespec,
    t2: time::Timespec,
}

fn time_from_https(client: &Client, server: String) -> HttpsTimes {
    let url = "https://".to_string() + &server + "/.well-known/time";


    debug!("HEAD {}", url);
    let t0 = time::now_utc().to_timespec();
    let res = client.head(&url).send().unwrap();
    let t2 = time::now_utc().to_timespec();

    let headers = res.headers.clone();
    let date = headers.get::<Date>().unwrap();
    debug!("Date: {}", date);

    let Date(HttpDate(tm)) = *date;

    debug!("Local: {:?}", tm);

    let tm_utc = tm.to_utc();

    debug!("UTC: {:?}", tm_utc);

    let t1 = tm_utc.to_timespec();

    debug!("t0: {:?}", t0);
    debug!("t1: {:?}", t1);
    debug!("t2: {:?}", t2);

    HttpsTimes {
        t0: t0,
        t1: t1,
        t2: t2,
    }
}

pub struct SimpleLogger;

impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &LogMetadata) -> bool {
        metadata.level() <= LogLevel::Debug
    }

    fn log(&self, record: &LogRecord) {
        if self.enabled(record.metadata()) {
            if record.location().module_path() == "httpstime_rs" {
                println!("{} {:<5} [{}] {}",
                         time::strftime("%Y-%m-%d %H:%M:%S", &time::now()).unwrap(),
                         record.level().to_string(),
                         "httpstime-rs",
                         record.args());
            }
        }
    }
}
